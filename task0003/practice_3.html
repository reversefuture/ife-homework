<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>practice3</title>
</head>
<body>
	<button id = "box" name = "box">Click Me!</button>
<script>
//     var name = "window";
// function showName(event){
// 	window.event.cancelBubble=true;
//         alert(this.name);
//     }
// document.getElementById("box").attachEvent("onclick", showName);//window
// document.getElementById("box").addEventListener("click", showName, false);//box
	/*function fn(x){
	var max=10;
	return function bar(x) {
	if(x>max){//自由变量取值，在声明函数的上下文取
	console.log(x);
	}
	}
	}
	var f1=fn(),
	max=100;
	f1(15);//15
*/


	var name = "window";
	var Bob = {
    name: "Bob",
    showName: function(){
        alert(this.name);
    }
	}

	/*var Tom = {
	name: "Tom",
	showName: function(){
	Bob.showName();
	}
	};

	Tom.showName();　　//Bob 直接执行Bob的showName()，所以this是Bob；*/

	/*var fun = Bob.showName;//引用函数
	fun();　　//window Bob.showName的函数赋值给fun，由于Bob是由匿名类构造的，赋值的也只是函数，及回调函数（函数的引用？），本身是没有对象的。所以showName中的this就没有对象了，没有对象时就是window。*/

	/*var Tom = {
	name: "Tom",
	showName: function(){
	var fun = Bob.showName;
	fun();
	}
	};*/

	// Tom.showName();　　//window 给fun赋值为Bob.showName时，因为fun本身是临时变量（或者叫私有变量），也就没有所属对象；因为Bob.showName赋值的是函数，相当于回调函数，是没有对象的，fun和Bob.showName回调都没有对象，所以没有对象时还是window。

	var Tom = {
	name: "Tom",
	fun: undefined,
	showName: function(){
	this.fun = Bob.showName;
	this.fun();

	}
	};

	Tom.showName();　　//Tom	虽然赋值的Bob.showName是回调函数，没有对象，但fun是有所属对象的就是Tom，所以结果是Tom。

	


</script>

	

</body>
</html>